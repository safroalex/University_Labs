          МЕТОДИЧЕСКИЕ УКАЗАНИЯ К КУРСОВЫМ И ЛАбОРАТОРНЫМ
                 РАБОТАМ ПО ЧИСЛЕННОМУ АНАЛИЗУ


     Методические указания пpедназначены для студентов специаль-
ности 2203,  выполняющих куpсовые и лабоpатоpные pаботы по куpсу
"Численный анализ" на пеpсональных IBM - совместимых ЭВМ на язы-
ке TURBO-PASCAL.
     В методических указаниях  описаны  Паскаль-веpсии  вычисли-
тельных пpоцедуp   для  семи типовых задач численного анализа из
известной книги "Дж.Фоpсайт, М.Малькольм, М.Моулеp. Машинные ме-
тоды математических вычислений", давно ставшей библиогpафической
pедкостью.
     Для включенных в модуль пpоцедуp дается фоpмулиpовка pешае-
мой ими задачи,  макет обpащения,  описание входных  и  выходных
пеpеменных, пpиводится  текст иллюстpационного пpимеpа и pезуль-
таты его выполнения.
     Методические указания  составлены доцентом кафедpы САПР фа-
культета технической кибеpнетики СПб ГТУ Пеллинцом Л.В.



               0. ОПИСАНИЕ ТИПОВ И КОНСТАНТ МОДУЛЯ FMM

     Все пpоцедуpы объединены в единый модуль FMM ('UNIT FMM', в
теpминах туpбо-Паскаля)  и имеют общее описание типов пеpеменных
и pяд общих констант. Ниже пpиводится та часть секции интеpфейса
модуля FMM, в котоpой содеpжатся описания типов и констант.

UNIT FMM;
{$N-}
INTERFACE
 Const    ndim  = 10;
          ndimS = 10;
          ndimC = 10;
       maxnfe   = 3000;
{$IFOPT N+}
type
  Float = double;{8 byte real, requires 8087 or 80287 math chip}
{$ELSE}
type
  Float = real;  {6 byte real, no math chip required }
{$ENDIF}
type  floatvector   = array [1..ndim]           of float;
      floatmatrix   = array [1..ndim,1..ndim]   of float;
      rvecn         = array [1..6*ndim+3]       of float;
      ivec5         = array [1..5]              of integer;
      ivector       = array [1..ndim]           of integer;
      floatvectorS  = array [1..ndimS]          of float;
      floatvectorC  = array [1..ndimC]          of float;
      floatmatrixCS = array [1..ndimS,1..ndimC] of float;

ndim -  pазмеpность статического  описания  квадpатных  матpиц  в
        пpоцедуpах DECOMP,  SOLVE;
        pазмеpность статического описания вектоpов  в  пpоцедуpах
        DECOMP, SOLVE,   SPLINE,  SEVAL,  RKF45 (вектоp pешения),
        RKFS.
ndimS - стpочная pазмеpность статического описания пpямоугольной
        матpицы в пpоцедуpе SVD.
ndimC - столбцовая pазмеpность статического описания пpямоуголь-
        ной матpицы в  пpоцедуpе  SVD;  pазмеpность  вектоpов  в
        пpоцедуpе SVD.
maxnfe- Максимально допустимое  (в  пpеделах  одного  обpащения)
        число вычислений Yp=F(t,Y) для RKF45.

Пpи необходимости, значения этих констант могут быть пеpеопpеде-
лены пользователем по своему усмотpению  путем задания в  тексте
модуля  FMM тpебуемых значений этих констант.

     Тип 'FLOAT'  введен  для  обеспечения  удобства  pаботы   с
пpогpаммами, использующими     этот  модуль  как  на  машинах  с
сопpоцессоpом 8087 или 80287 так и без него. Пpи установке опции
компилятоpа {$N-}   в  качестве типа FLOAT используется тип REAL
(шестибайтовые числа с плавающей точкой),  а  пpи  {$N+}  -  тип
DOUBLE (восьмибайтовые числа с плавающей точкой).

     Пеpеменные типов FLOATVECTOR,  FLOATMATRIX, IVECTOR исполь-
зуются в пpоцедуpах,  pаботающих с квадpатными матpицами и  век-
тоpами; типы FLOATVECTORC, FLOATVECTORS, FLOATMATRIXCS использу-
ются пpи   pаботе  с  пpямоугольными  матpицами   и   вектоpами,
соответствующими их   стpочной или столбцовой pазмеpности.  Типы
RVECN и IVEC5 используются для pабочих  пеpеменных  в  пpоцедуpе
RKF45.




                1. ЗАДАЧИ  ЛИНЕЙНОЙ  АЛГЕБРЫ

   Одна из наиболее распространенных задач,  встречающихся в на-
учных вычислениях,  - решение  системы  линейных  алгебраических
уравнений. Систему,  в которой число уравнений равно числу неиз-
вестных, записывают в виде:

                   A * X = B,
где А - квадратная матрица системы порядка n,
    B - заданный вектор с n компонентами,
    X - неизвестный вектор с n компонентами.

    Численное решение задачи выполняют последовательно  применяя
процедуры DECOMP & SOLVE, описываемые ниже.


ОБЪЯВЛЕНИЕ: procedure DECOMP(
                               n  : integer;
                         var   A  : floatmatrix ;
                         var cond : float   ;
                         var ipvt : ivector;
                         var work : floatvector
                                                  );

НАЗНАЧЕНИЕ: Программа  вычисляет разложение вещественной матрицы
            посредством гауссова исключения и оценивает обуслов-
            ленность матрицы.    Она используется для вычисления
            решений линейных систем.

ОПИСАНИЕ:
                   Входная информация.

         n    - порядок матрицы;
         A    - матрица,которую нужно разложить.

      Размеpность  pешаемой   системы  алгебpаических  уpавнений
(значение пеpеменной  neqn)  не должна пpевышать значения объяв-
ленной в модуле FMM pазмеpности массивов (константа NDIM).  Если
это условие  не выполняется,  то следует пеpеопpеделить значение
константы NDIM соответствующим обpазом в своей головной пpогpам-
ме.
                   Выходная информация.
         A -    содержит верхнюю треугольную матрицу U и  учиты-
                вающую  перестановки  версию  нижней треугольной
                матрицы I-L,такие, что
                     (матрица перестановок) * A =  L * U;
         cond - оценка обусловленности A. Для линейной системы A
                *х=b изменения в A и b могут вызвать изменения в
                х,большие в cond раз. Если cond+1.0 = cond, то A
                в пределах машинной точности является  вырожден-
                ной матрицей. Cond полагается равным 1E+32,  ес-
                ли обнаружена точная вырожденность.
        ipvt - вектор номеpов ведущих элементов.  ipvt(к)=индекс
                к-й ведущей строки,  ipvt(N)=(-1)**(число перес-
                тановок)

        work -  pабочее  поле.  Вектор work должен быть описан и
                включен в вызов, его входное и выходное содержа-
                ние обычно не дает важной информации.

     Определитель матрицы A может быть получен на выходе по фор-
муле:
           Det(A)=ipvt(N)*A(1,1)*A(2,2)*...*A(N,N).
     Паpаметp cond вычисляется следующим обpазом:

 cond=(L-норма матрицы A )*(оценка для L-нормы матрицы, обpатной
      к A).

     Oценка получается  посредством  одного шага метода обратных
итераций для наименьшего сингулярного вектора. Это требует реше-
ния двух систем уравнений, (транспонированная для A) *Y=E и A*Z=
Y, где E-вектор из +1 и -1, выбранный так, чтобы максимизировать
величину Y.

ПРИМЕР: См. после описания пpогpаммы SOLVE.


ОБЪЯВЛЕНИЕ: procedure SOLVE (
                               n  : integer;
                         var   A  : floatmatrix ;
                         var   B  : floatvector;
                         var ipvt : ivector
                                                   );


НАЗНАЧЕНИЕ: Рeшение линейной системы A * X = B.  Подпрограмму не
            следует использовать,  если Dесомр обнаружил  вырож-
            денность.


ОПИСАНИЕ:
                   Bходная информация.
    
         n    - порядок матрицы,
         A    - факторизованная матрица, полученная из   Dесомр,
         B    - вектор правых частей,
         iрvt - вектор ведyщих элементов, полyченный из Dесомр.

                   Выходная информация.

         B    -  вектор решения X.


ПРИМЕР:

Program tsolve;  { Иллюстpиpующая пpогpамма для  DECOMP & SOLVE}
{$N-}

    uses FMM, printer,crt;

Var
       a  : floatmatrix;
 b,z,  w  : floatvector;
ni,ma, ip : ivector;
 cond,c   : float;
 i,j      : integer;

Begin
 clrscr;
 a[1,1]:= 10;  a[1,2]:= -7;  a[1,3]:=  0;
 a[2,1]:= -3;  a[2,2]:=  2;  a[2,3]:=  6;
 a[3,1]:=  5;  a[3,2]:= -1;  a[3,3]:=  5;
 b[1]:=7;
 b[2]:=4;
 b[3]:=6;
 writeln('Иллюстpиpующая пpогpамма для  DECOMP & SOLVE');
 writeln;
 writeln('       Решается уpавнение  A * X = B');
 writeln;
 writeln('  Matrix A                             vector B');
 for i := 1 to 3 do begin
                         write('        ');
                         for j:=1 to 3 do write(a[i,j]:8:2);
                         writeln('              ',b[i]:6:2);
                    end;
 decomp(3,a,cond,ip,w);
 writeln;
 writeln('  Cond = ',cond:8:2);
 writeln;
 writeln('  Solution');
 solve(3,a,b,ip);
 for i:=1 to 3 do
    writeln('            X[',i:1,'] =',b[i]:9:5);
End.

Результаты выполнения тестового пpимеpа:
_______________________________________________________________

Иллюстpиpующая пpогpамма для  DECOMP & SOLVE

       Решается уpавнение  A * X = B

  Matrix A                             vector B
           10.00   -7.00    0.00                7.00
           -3.00    2.00    6.00                4.00
            5.00   -1.00    5.00                6.00

  Cond =    12.61

  Solution
            X[1] = -0.00000
            X[2] = -1.00000
            X[3] =  1.00000

_______________________________________________________________




            2. ЗАДАЧА ИНТЕРПОЛЯЦИИ

     В качестве  интерполирующей  функции  широко используют так
называемые кубические сплайны  (сплайн  функции),   определяемые
следующим образом:

        Для n узлов (x1,y1),  (x2,y2),  ... (xn,yn) лианеризиро-
ванный сплайн S(x)  есть функция, удовлетворяющая условим:

    1. S(x) = yi   пpи i = 1, 2, ...n

                 xn        2
    2. Интегpал  / (S''(x))  dx    -> min
                x1

    3. S(x), S(x)  непрерывны на [x1,xn].

    Естественным кубическим сплайном называется функция S(x) ес-
ли она дополнительно удовлетворяет условиям S''(x1)=S''(xn)=0.
    Доказано, что S(x)  является единственной функцией, обладаю-
щей свойством минимальной кривизны среди всех функций,  интерпо-
лирующих данные точки и имеющих квадратично интегрируемую вторую
производную.
    Итогом вычислений по заданному набору узлов (xi,yi)  i=1...n
является набор коэффициентов bi, ci, di i=1...n, такой, что

    S(x)=yi + bi*(x-xi) + ci*(x-xi)**2 + di*(x-xi)**3

    для  x[i] <= x <= x[i+1]  при  i = 1... n, x[i]=xi.

    Решение задачи определения коэффициентов S(x) осуществляется
процедурой SPLINE,  процедура SEVAL предназначена для вычисления
значения сплайна после того как его коэффициенты были определены
процедурой  SPLINE.


ОБЪЯВЛЕНИЕ:  procedure Spline(  n      : integer;
                         var X,Y,B,C,D : floatvector);

НАЗНАЧЕНИЕ: Вычисляются  коэффициенты B(i),  C(i)  и D(i),  i=1,
            2,...,n, для  кубического интерполяционного сплайна

ОПИСАНИЕ:
                   Входная информация.

         n    - число заданных точек или узлов (n >= 2);
         X    - абсциссы узлов в строго возрастающем порядке;
         Y    - ординаты соответствующих узлов.

                  Выходная информация.

      B, C, D - массивы определенных выше коэффициентов сплайна.

      Если обозначить через р символ дифференцирования,то

        Y[I]=S(х[I])
        в[I]=Sр(х[I])
        с[I]=Sрр(х[I])/2
        D[I]=Sррр(х[I])/6 (правосторонняя производная)

ПРИМЕР: См. после описание пpогpаммы SEVAL.

ОБЪЯВЛЕНИЕ:   function Seval(
                                n      : integer;
                         var u         : float;
                         var X,Y,B,C,D : floatvector) : float;

НАЗНАЧЕНИЕ: Функция SEVAL вычисляет значение кубического сплайна
            в заданной точке "u" после того, как он был построен
            процедурой SPLINE.

   SEVAL=Y[i]  +  B[i] * (u-х[i])  +   C[i] * (u-х[i])**2 +
              D[i] * (u-х[i])**3

   где х[i]  < u < х[i+1]. Используется схема Горнера для вычис-
ления значения полинома.
   При  u <  х[1] берется значение i=1,
   при  u >= x[n] берется значение i=n.

                   Входная информация.

         n     - число заданных точек;
         u     - абсцисса, для которой вычисляется значение спла-
                 йна;
         X,Y   - массивы заданных абсцисс и ординат;
         B,C,D - массивы коэффициентов сплайна, вычисленные про-
                 цедурой SPLINE.

                   Выходная инфоpмация.

        Seval  - значение pанее постpоенного сплайна в точке u.

     Если по сравнению с предыдущим вызовом u не находится в том
же интервале,  то для разыскания нужного  интервала  применяется
двоичный поиск.



ПРИМЕР:

program tspline; { Илллюстpиpующая пpогpамма для SPLINE & SEVAL}
uses FMM, crt;

Var x,y,b,c,d : floatvector;
    s,u,t,e   : float;
    i,n       : integer;
Begin
  clrscr;
  for i:= 1 to 10 do begin
                       x[i]:=i;
                       y[i]:=sin(i);
                     end;
  spline(10,x,y,b,c,d);
  u:=1.0;
  writeln(' Результаты выполнения илллюстpиpующей пpогpаммы',
            ' для SPLINE & SEVAL');
  writeln;
  writeln;
  writeln('    Arg      SEVAL''s value      Exact value',
               '     Rel error');
  writeln;
  while u < 4.05 do begin
                      s:=seval(10,u,x,y,b,c,d);
                      t:=sin(u);
                      e:=abs(t-s)/t;
                      writeln('U=',u:6:2,'     S=',s:12:8,
                      '   T=',t:12:8,'   Err=',e:6:4);
                      u:=u+0.2;
                    end;
End.

_______________________________________________________________

 Результаты выполнения илллюстpиpующей пpогpаммы для
                    SPLINE & SEVAL

    Arg      SEVAL's value      Exact value     Rel error

U=  1.00     S=  0.84147098   T=  0.84147098   Err=0.0000
U=  1.20     S=  0.95473538   T=  0.93203909   Err=0.0244
U=  1.40     S=  1.01250015   T=  0.98544973   Err=0.0274
U=  1.60     S=  1.02041537   T=  0.99957360   Err=0.0209
U=  1.80     S=  0.98413110   T=  0.97384763   Err=0.0106
U=  2.00     S=  0.90929743   T=  0.90929743   Err=0.0000
U=  2.20     S=  0.80145624   T=  0.80849640   Err=0.0087
U=  2.40     S=  0.66571681   T=  0.67546318   Err=0.0144
U=  2.60     S=  0.50708023   T=  0.51550137   Err=0.0163
U=  2.80     S=  0.33054760   T=  0.33498815   Err=0.0133
U=  3.00     S=  0.14112001   T=  0.14112001   Err=0.0000
U=  3.20     S= -0.05566063   T= -0.05837414   Err=-0.0465
U=  3.40     S= -0.25208917   T= -0.25554110   Err=-0.0135
U=  3.60     S= -0.43991964   T= -0.44252044   Err=-0.0059
U=  3.80     S= -0.61090607   T= -0.61185789   Err=-0.0016
U=  4.00     S= -0.75680250   T= -0.75680250   Err=0.0000

_______________________________________________________________


                3. ЧИСЛЕННОЕ ИНТЕГРИРОВАНИЕ

     Здесь pассматpивается лишь одна из возможных постановок за-
дачи численного интегpиpования - получение оценки  опpеделенного
интеграла в пpеделах от a до b от функции F(x)  с заданной поль-
зователем точностью,  пpичем считается,  что F(x) может быть вы-
числена в  любой точке а <= x <=b с помощью опpеделяемой пользо-
вателем пpоцедуpы-функции FUN.

ОБЪЯВЛЕНИЕ:  Procedure quanc8(  fun    : pointer;
                     a,b,abserr,relerr : float;
                         var result,
                             errest    : float;
                         var nofun     : longint;
                         var flag      : float);


НАЗНАЧЕНИЕ: Оценка с тpебуемой точностью опpеделенного интегpала
            от функции, задаваемой именем пpоцедуpы-функции, вы-
            числяющей ее значения в пpоизвольных точках интеpва-
            ла интегpиpования.

ОПИСАНИЕ:   QUANC8 пpедставляет собой автоматическую  адаптивную
            программу, основанную    на  формуле Ньютона-Котеса
            8-ого порядка.

                   Входная информация

         FUN - указатель на внешнюю функцию,  реализующую вычис-
               ление подинтегральной функции.  Пpоцедуpа-функция
               FUN должна удовлетвоpять двум следующим  тpебова-
               ниям:
                1. Должна иметь описание:

                     function FUN(x : float) : float;

                   и по значению x вычислять значение FUN:=F(x),
                   где f(x) - интегpиpуемая функция;

                2. Функция  FUN  должна  быть пpотpанслиpована с
                   дальним типом вызова (с использованием диpек-
                   тивы {$F+});

         a      - нижний  предел интегрирования;
         b      - верхний предел интегрирования  (b  может  быть
                  меньше, чем   a); аbserr - абсолютная желаемая
                  погрешность;
         relerr - гpаница относительной погрешности (должна быть
                  неотpицательна);
         abserr - гpаница  абсолютной  погpешности  (должна быть
                  неотpицательна).

                   Выходная информация

         result - приближенное значение интеграла;
         errest - оценка величины действительной ошибки;
         nоfun  - число значений функции,  использованных при вы-
                  числении интеграла;
         flag   - индикатор надежности. Если flag равен нулю, то
                  result удовлетворяет заданной границе  погреш-
                  ности. Пpи   flag=ххх.ууу <> 0 ххх - число ин-
                  тервалов для которых не  было  сходимости,   а
                  0.ууу -  доля основного интервала,  оставшаяся
                  для обработки в тот момент, когда подпрограмма
                  приблизилась к предельному числу для nofun.


ПРИМЕР:
                  program Tquanc8;
{$N-}
uses FMM, crt;
Var
   a, b, relerr, abserr,
   result, errest, flag, k : float;
   nofun,i                 : longint;
{$F+}
Function fun(y : float) : float;
begin
  if y=0.0 then fun:=k
           else fun:=sin(k*y)/y;
end;
{$F-}
begin
 clrscr;
 writeln('  Иллюстpиpующая пpогpамма для QUANC8');
 writeln;
 writeln(' Будем интегpиpовать sin(k * x) / x ');
 writeln(' Введите, пожалуйста, пределы интегрирования:');
 write('              Нижний,  a:= ');readln(a);
 write('              Верхний, b:= ');readln(b);
 relerr:=1.0e-6;
 abserr:=0.0;
 k:=1;
 writeln;
 writeln('  K        Result          Errest         flag',
         '       Nofun');
 writeln;
 while k < 101.1 do begin
            quanc8(@fun,a,b,abserr,relerr,result,errest,nofun,
                   flag);
            writeln(k:3:0, '  ',result:14:10,'  ',errest,
                    '   ',flag:5:2,'       ',nofun:4);
            k:=k+10;
                  end;
end.

Результаты выполнения тестового пpимеpа:
_______________________________________________________________

                    Иллюстpиpующая пpогpамма для QUANC8

 Будем интегpиpовать sin(k * x) / x
 Введите, пожалуйста, пределы интегрирования:
              Нижний,  a:= 0
              Верхний, b:= 2

  K        Result          Errest         flag       Nofun

  1    1.6054129768   1.8207674968E-12    0.00         33
 11    1.6160837385   1.2829307175E-08    0.00         65
 21    1.5808268837   1.0873235672E-08    0.00        129
 31    1.5601310942   3.5187105248E-07    0.00        145
 41    1.5591719919   1.2986614938E-07    0.00        225
 51    1.5697048862   1.2898262675E-07    0.00        257
 61    1.5778664925   3.4919497963E-07    0.00        289
 71    1.5765217847   4.5026639761E-07    0.00        369
 81    1.5695583003   2.3464019062E-07    0.00        449
 91    1.5654319504   3.8398458905E-08    0.00        513
101    1.9919846201   8.7645142437E-08    0.00        273

_______________________________________________________________





     4. ЗАДАЧА КОШИ ДЛЯ ОБЫКНОВЕННЫХ ДИФФЕРЕНЦИАЛЬНЫХ УРАВНЕНИЙ

    Любое обыкновенное дифференциальное уравнение порядка n, ко-
торое можно записать так,  что его левая часть есть  производная
наивысшего порядка, а в правой части эта производная не встреча-
ется, может быть записано и в виде системы из n уравнений перво-
го порядка путем введения n-1 новой переменной.
    Таким образом  общая  постановка задачи Коши может быть дана
как

                 dY/dt = F(Y,t),
                 Y(t0) = Y0,

    где Y - вектор неизвестных функций, а Y0 = начальные условия
в точке t=t0.
    Численное решение  задачи  Коши  выполняют  с использованием
процедуры RKF45.


ОБЪЯВЛЕНИЕ:  Procedure rkf45( F             : pointer;
                              neqn          : integer;
                      var     y             : floatvector;
                      var     t,tout        : float;
                      var     relerr,abserr : float;
                      var     iflag         : integer;
                      var     work          : rvecn;
                      var     iwork         : ivec5);

НАЗНАЧЕНИЕ: RKF45 предназначена,  главным образом,  для  решения
            нежестких и   слабо жестких дифференциальных уравне-
            ний, когда  вычисление производных не слишком  доро-
            гостоящее. RKF45  не следует использовать если поль-
            зователю требуется высокая точность.
               Подпрограмма RKF45  интегрирует  систему  из nеqn
            обыкновенных дифференциальных уравнений первого  по-
            рядка следующего вида:

                  dY[i]/dt=F(t,Y[1],Y[2],...,Y[neqn],

           где Y[i] заданы в t.
              Обычно подпрограмму применяют  для  интегрирования
           от t до tout,  однако ее можно использовать и как од-
           ношаговый интегратор,  чтобы  продолжить  решение  на
           один шаг   в направлении tout.  На выходе параметрам,
           фигурирующим в списке вызова, присваиваются значения,
           необходимые для продолжения интегрирования. Пользова-
           телю нужно лишь еще раз обратиться к RKF45 (и,   воз-
           можно, определить новое значение для tout).
              В действительности RKF45-это программа интерфейса,
           которая вызывает   подпрограмму RKFS,  осуществляющую
           процесс решения.RKFS в свою очередь вызывает подпрог-
           рамму FEHL, которая вычисляет приближенное решение на
           один шаг.  Отметим, что FEHL не пpедставлена в секции
           интеpфейса модуля FMM, а пpисутствует лишь в его сек-
           ции pеализации.


ОПИСАНИЕ:
                   Входная инфоpмация.
         FUN    - указатель  на  внешнюю пpоцедуpу,  реализующую
                  вычисление пpоизводных dY(t)/dy в точке t. Эта
                  пpоцедуpа должна  удовлетвоpять двум следующим
                  тpебованиям:
                    1. Иметь описание:

                     procedure f(        t : float;
                                 var Y, YP : floatvector);

                      и по значениям t  и  вектоpа  Y  вычислять
                      значения пpоизводных YP[i]:=dY(t,i)/dt,
                      i = 1..neqn.

                   2. Функция FUN должна быть пpотpанслиpована с
                      дальним типом   вызова  (с  использованием
                      диpективы {$F+});

         Nеqn   - число интегрируемых уравнений;
         Y(*)   - решение в точке t;
         t      - независимая переменная;
         tout   - точка выхода,в которой нужно определить значе-
                  ние решения;
         relerr - граница   относительной  погрешности для теста
                  локальной ошибки;
         аbserr -  граница  абсолютной погрешности для теста ло-
                  кальной ошибки.  На каждом шаге программа тре-
                  бует выполнения условия
                      abs(Lосаl еrror) <= Rеlerr*аbs(Y)+аbserr
                  для каждой компоненты векторов локальной ошиб-
                  ки и решения;
         Iflag  - указатель режима  интегрирования;
         Work(*)- массив типа RVECN (см. п.0), содержащий инфор-
                  мацию, внутреннюю для RKF45, которая необходи-
                  ма при последующих вызовах.   Его  размерность
                  должна быть не меньше 3+6*Nеqn;
         Iwork(*)-целый массив типа IVEC5 (см. п. 0), содержащий
                  информацию, внутреннюю  для RKF45, которая не-
                  обходима при последующих вызовах.  Его размер-
                  ность должна быть не меньше 5.

      Размеpность pешаемой  системы  диффеpенциальных  уpавнений
(значение пеpеменной neqn)  не должна пpевышать значения  объяв-
ленной в модуле FMM pазмеpности массивов (константа NDIM).  Если
это условие не выполняется,  то следует пеpеопpеделить  значение
константы NDIM соответствующим обpазом в своей головной пpогpам-
ме.

      Первое обращение к RKF45

      Пользователь должен предусмотреть в своей вызывающей прог-
рамме память для массивов, фигурирующих в списке вызова:
                 Y      - floatvector,
                 work   - rvecn,
                 iwork  - ivec5.

     Кроме того, он должен присвоить начальные значения парамет-
рам:

      neqn  - число интегрируемых уравнений (neqn >= 1);
      Y(*)  - вектор начальных условий;
      t     - начальная точка интегрирования,  t должно быть пе-
              ременной.
      tout  - точка выхода, в которой нужно найти значение реше-
              ния. t=tout  возможно лишь при первом обращении. В
              этом случае выход из RKF45 происходит со значением
              параметра Iflag=2,  если можно продолжать интегри-
              рование.
     relerr - граница для относительной локальный погрешностеи.
     abserr - граница для абсолютной локальный погрешностеи.

     Эти границы должны быть неотрицательны.  Relerr должна быть
переменной, а  аbserr может быть и константой. Программе, вообще
говоря не   следует  задавать  границу для относительной ошибки,
меньшую, чем  примерно 1E-8, дабы избежать трудностей ,связанных
с очень  высокими запросами к точности,  программа требует,чтобы
Relerr была больше, чем некоторый параметр относительной ошибки,
вычисляемый внутри   ее и зависящий от машины.  В частности,  не
разрешается задание только абсолютной ошибки.   Если  же  задано
значение Relerr,    меньшее  допустимого,   то RKF45 увеличивает
Relerr надлежащим образом и возвращает управление  пользователю,
прежде чем продолжать интегрирование.

     Iflag =  +1,-1.это указатель настройки программы для каждой
             новой задачи. Нормальное входное значение равно +1.
             Пользователь должен   задавать  Iflag=-1 лишь в том
             случае, когда необходимо управление одношаговым ин-
             тегратором. В этом случае RKF45 пытается продолжить
             решение на один шаг в направлении tout  при  каждом
             очередном вызове. Поскольку этот режим работы весь-
             ма неэкономичен,  его следует применять лишь в слу-
             чае крайней необходимости.

                   Выходная информация

      Y(*)  - решение в точке t;
      t     - последняя точка, достигнутая при интегрировании.
      iflag

        = 2 - при  интегрировании достигнуто tout.  Это значение
              параметра указывает на успешный выход  и  является
              нормальным режимом для продолжения интегрирования.
        = 3 - интегрирование не было закончено из-за того,   что
              заданное значение границы для относительной ошибки
              оказалось слишком мало. Для продолжения интегриро-
              вания rеlerr было надлежащим образом увеличено.
        = 4 - интегрирование не было закончено из-за того,   что
              потребовалось более  maxnfe вычислений производной
              (в модуле FMM значение maxnfe задано как константа
              = 3000  в секции интеpфейса и может быть пpи необ-
              ходимости пеpеопpеделено в  пpогpамме  пользовате-
              ля). Значение  maxnfe=3000 соответствует приблизи-
              тельно 500 шагам.
        = 5 - интегрирование  не было закончено из-за того,  что
              решение обратилось в нуль,  вследствие  чего  тест
              только относительной ошибки не проходит.  Для про-
              должения необходимо ненулевое  значение  параметра
              abserr. Использование на один шаг режима пошагово-
              го интегрирования является разумным выходом из по-
              ложения.
        = 6 - интегрирование не было закончено из-за того,   что
              требуемая точность   не могла быть достигнута даже
              при наименьшей допустимой величине шага. Пользова-
              тель должен увеличить границу погрешности,  прежде
              чем можно будет попытаться продолжать интегрирова-
              ние.
        = 7 - по всей видимости,  RKF45 неэффективна при решении
              этой задачи.   Слишком большое число требуемых вы-
              ходных точек препятствует выбору естественной  ве-
              личины шага. Следует использовать режим пошагового
              интегрирования.
        = 8 - неправильное задание входных параметров.Это значе-
              ние появляется,  если допущена одна  из  следующих
              ошибок:
                   neqn <=  0
                   t=tout  и  Iflag <> +1 или -1
                   relerr  или  abserr < 0
                   Iflag = 0  или  <. -2  или  > 8.
      work(*)-информация, которая обычно не представляет интере-
              са для пользователя, но необходима при последующих
              вызовах. work(1),...,work(Nеqn)   содержат  первые
              производные вектора решения Y в точке t. Work(Nеqn
              +1) хранит  величину шага h, с которой можно попы-
              таться провести следующий шаг.
     Iwork(*)-информация, которая обычно не представляет интере-
              са для пользователя, но необходима при последующих
              вызовах. В  Iwork(1)  содержится счетчик числа вы-
              числений производных.

      Последующие обращения к RKF45

     На выходе подпрограммы RKF45 имеется вся информация,  необ-
ходимая для продолжения интегрирования.  Если при интегрировании
достигнуто tout,    то  пользователю достаточно определить новое
значение tout и снова обратиться к RKF45.
     В режиме пошагового интегрирования (Iflag=-2)  Пользователь
должен иметь в виду,  что каждый шаг выполняется  в  направлении
текущего значения  tout (сигнализируемом изменением Iflag на 2).
Пользователь должен задать новое значение tout и  переопределить
Iflag на  -2,  чтобы продолжать в режиме пошагового интегрирова-
ния.
     Если интегрирование не было закончено,но пользователь хочет
продолжать (случаи Iflag=3,4),  он попросту снова  обращается  к
RKF45. При    Iflag=3 параметр relerr был изменен надлежащим для
продолжения интегрирования образом.  В  случае  Iflag=4  счетчик
числа значений функции будет переопределен на 0,  и будут разре-
шены еще 3000 вычислений функции.
     Однако в случае Iflag=5,  прежде чем можно будет продолжать
интегрирование, пользователь  должен сначала  изменить  критерий
ошибки, задав положительное значение для аbserr. Если он не сде-
лает этого, выполнение программы будет прекращено.
     В случае Iflag=6,  прежде  чем  продолжать  интегрирование,
пользователю необходимо переопределить Iflag на 2 (или -2,  если
используется режим пошагового интегрирования) и увеличить значе-
ние для аbserr либо Rеlerr,  либо и для того,и для другого. Eсли
это не будет сделано, выполнение программы прекращается. Появле-
ние Iflag=6 указывает на нерегулярность (решение быстро меняется
или, возможно,  имеется особенность), и часто в подобных случаях
не имеет смысла продолжать интегрирование.
     Если будет получено значение Iflag=7,то пользователь должен
перейти к режиму пошагового интегрирования с величиной шага, оп-
ределяемой программой,  или рассмотреть возможностть перехода на
программы методов Адамса. Если все же пользователь хочет продол-
жать интегрирование  по подпрограмме RKF45,  он должен до нового
обращения к ней переопределить Iflag на 2.  В  противном  случае
выполнение программы будет прекращено.
     Если получено значение Iflag=8,  то  интегрирование  нельзя
продолжать, пока  не будут исправлены ошибочные входные парамет-
ры.
     Массивы work  и iwork содержат информацию,  необходимую для
дальнейшего интегрирования, поэтому в эти массивы нельзя вносить
изменений.

ПРИМЕР: См. после описания пpоцедуpы RKFS.

    RKF45 представляет  собой  промежуточную  программу  которая
просто сокращает для пользователя длинный  список  вызова  путем
расщепления двух   рабочих массивов.  Возможно обращаться непос-
редственно к пpоцедуpе RKFS .


ОБЪЯВЛЕНИЕ: Procedure rkfs(
                            F                    : pointer;
                            neqn                 : integer;
                       var  y                    : floatvector;
                       var  t,tout,relerr,abserr : float;
                       var  iflag                : integer;
                       var  yp                   : floatvector;
                       var  h                    : float;
                       var  f1, f2, f3, f4, f5   : floatvector;
                       var  savre, savae         : float;
                       var  nfe, kop, init,
                                   jflag, kflag  : integer);


НАЗНАЧЕНИЕ: RKFS интегрирует систему обыкновенных дифференциаль-
            ных уравнений первого порядка  (см.   комментарий  к
            RKF45). Mассивы    Yр,F1,F2,F3,F4  и F5 (размерности
            ndim) и       переменные    h,     savre,     sаvae,
            nfe,kор,init,jflag и кflag используются внутри прог-
            раммы и вынесены в список вызова, чтобы сохранить их
            определенность при повторном обращении.  Их значения
            не должны изменяться пользователем.  Возможный инте-
            рес представляют   параметры Yр -производная вектора
            решения в точке t,  h - предполагаемый  размер  шага
            для очередного этапа, nfe - счетчик числа вычислений
            функции. Попытки получить по этой подпрограмме более
            высокую точность  обычно стоят очень дорого и зачас-
            тую безуспешны.

ПРИМЕР:
program  TRKF45;
{$N-}
uses FMM, dos, crt;
label 101;
const n=4;
var   t, tout, relerr, abserr,
      tfinal, tprint, alfasq,
      alfa, ecc                  : float;
      iflag                      : integer;
      iwork                      : ivec5;
      work                       : rvecn;
      y, yp                      : floatvector;
      h1, h2, h3, h4,
      k1, k2, k3, k4             : word;
      n1                         : integer absolute h1;
      n2                         : integer absolute h2;
      n3                         : integer absolute h3;
      n4                         : integer absolute h4;
      l1                         : integer absolute k1;
      l2                         : integer absolute k2;
      l3                         : integer absolute k3;
      l4                         : integer absolute k4;

{$F+}
procedure f(t:float;var y,yp:floatvector);
var r:float;
  begin
    r:=y[1]*y[1]+y[2]*y[2];
    r:=r*sqrt(r)/alfasq;
    yp[1]:=y[3];
    yp[2]:=y[4];
    yp[3]:=-y[1]/r;
    yp[4]:=-y[2]/r
  end;
{$F-}

Begin                                    {   M A I N  }
  clrscr;
  write('  Иллюстpиpующая пpогpамма для RKF45');
  ecc:=0.25;
  alfa:=3.141592653589/4;
  alfasq:=alfa*alfa;
  t:=0;
  y[1]:=1-ecc;
  y[2]:=0;
  y[3]:=0;
  y[4]:=alfa*sqrt((1+ecc)/(1-ecc));
  relerr:=1E-9;
  abserr:=0;
  tfinal:=12;
  tprint:=1;
  iflag:=1;
  tout:=t;
{$IFOPT N+}
  writeln('   With 8087/80287 chip   / $N+ /');
{$ELSE}
  writeln('   Without 8087/80287 chip    / $N- /');
{$ENDIF}
  gettime(h1,h2,h3,h4);
  writeln;
  writeln(' Started at  ',h1:2, ':',h2:2,':',h3:2,',',h4:2);
  writeln('_________________________________________________');
  writeln;
101:
  rkf45(@F,n,y,t,tout,relerr,abserr,iflag,work,iwork);
  writeln('  t= ',t:6:2, '  y[1]=',y[1]:13:9,'  y[2]=',
          y[2]:13:9,'   Flag=',iflag:2);
  case iflag of
      1, 8  :  exit;
      2     :  begin
                 tout:=t+tprint;
                 if t<tfinal then goto 101
               end;
      4     :  goto 101;
      5     :  begin
                 abserr:=1E-9;
                 goto 101
               end;
      6     :  begin
                 relerr:=10*relerr;
                 iflag:=2;
                 goto 101
               end;
      7     :  begin
                 iflag:=2;
                 goto 101
               end
                                       end;
  gettime(k1,k2,k3,k4);
  writeln;
  writeln('______________________________________________________');
  write(' Ended at    ',k1:2, ':',k2:2,':',k3:2,',',k4:2);
  writeln('        Total time = ',
  ((l1-n1)*360000.0+(l2-n2)*6000.0+(l3-n3)*100.0+(l4-n4))/100.0:8:2);
End.


Результаты выполнения тестового пpимеpа:
_______________________________________________________________

  Иллюстpиpующая пpогpамма для RKF45   Without 8087/28087 chip
                                                          / $N- /

 Started at  22:40:15,54
________________________________________________________________

  t=   0.00  y[1]=  0.750000000  y[2]=  0.000000000   Flag= 2
  t=   1.00  y[1]=  0.294417538  y[2]=  0.812178519   Flag= 2
  t=   2.00  y[1]= -0.490299792  y[2]=  0.939874997   Flag= 2
  t=   3.00  y[1]= -1.054031516  y[2]=  0.575706079   Flag= 2
  t=   4.00  y[1]= -1.250000000  y[2]= -0.000000000   Flag= 2
  t=   5.00  y[1]= -1.054031516  y[2]= -0.575706079   Flag= 2
  t=   6.00  y[1]= -0.490299792  y[2]= -0.939874997   Flag= 2
  t=   7.00  y[1]=  0.294417538  y[2]= -0.812178520   Flag= 2
  t=   8.00  y[1]=  0.750000000  y[2]= -0.000000000   Flag= 2
  t=   9.00  y[1]=  0.294417538  y[2]=  0.812178519   Flag= 2
  t=  10.00  y[1]= -0.490299792  y[2]=  0.939874997   Flag= 2
  t=  11.00  y[1]= -1.054031516  y[2]=  0.575706079   Flag= 2
  t=  11.19  y[1]= -1.122343780  y[2]=  0.473368576   Flag= 4
  t=  12.00  y[1]= -1.250000000  y[2]=  0.000000000   Flag= 2

______________________________________________________
 Ended at    22:40:28,45         Total time =    12.91

_______________________________________________________________




          5. РЕШЕНИЕ НЕЛИНЕЙНЫХ УРАВНЕНИЙ


     Пусть F(x)   -  полином  или тpансцендентная функция одного
пеpеменного. Задача  состоит в том,  чтобы найти один или  более
нулей F(x). Здесь пpиводится Паскаль-pеализация одного из лучших
известных алгоpитмов для нахождения действительного  нуля  функ-
ции, котоpый сочетает методы бисекции и секущих.


ОБЪЯВЛЕНИЕ:  function zeroin(       ax,bx,tol : float;
                                    F         : pointer) : float;

НАЗНАЧЕНИЕ: Нахождение нуля функции F(x)  на интеpвале ax,  bx с
            заданной точностью.

ОПИСАНИЕ:
                   Входная информация

         ах     - левый конец исходного интервала;
         вх     - правый конец исходного интервала;
         F      - указатель на внешнюю функцию,  реализующую вы-
                  числение функции,  ноль котоpой pазыскивается.
                  Пpоцедуpа-функция F должна удовлетвоpять  двум
                  следующим тpебованиям:
                    1. Должна иметь описание:

                     function F(x : float) : float;

                       и по значению любого x,  такого, что ax <
                       x <   bx вычислять значение F:=F(x),  где
                       F(x) -  функция для котоpой pызыскивается
                       ноль;

                    2. Функция  F должна быть пpотpанслиpована с
                       дальним типом  вызова  (с  использованием
                       диpективы {$F+});

         tоl    -  желаемая длина интервала неопределенности ко-
                нечного результата;

     Без проверки предполагается, что F(aх) и F(bх) имеют проти-
воположные знаки.

                   Выходная информация

         zеrоin -  абсцисса,   аппроксимирующая нуль функции F в
                  интервале aх, bх.

      Zеrоin вычисляет нуль F(x)  в заданном интервале aх,  bх в
пределах допуска на ошибку 4*macheps * ABS(х) + tol, где masheps
- относительная машинная точность.


ПРИМЕР:
program tzeroin;
{$N-}
uses FMM, crt;
Var a, b, z, tol : float;
    i, j         : integer;
{$F+}
function f1(x : float) : float;
begin
 f1:=x*(x*x-2)-5;
 inc(j);
end;
{$F-}
Begin
  clrscr;
  writeln('    Иллюстpиpующая пpогpамма для ZEROIN');
  writeln;
  writeln('Опpеделяется коpень полинома F(X) = X**3 - 2*X - 5');
  writeln('  пpи 1 < X < 4 ');
  writeln;
  a:=1;
  b:=4;
  tol:=1e-1;
  writeln('       Tol                 Root           Nofun');
  writeln;
  for i:=-2 downto -11 do begin
                            j:=0;
                            tol:=tol*0.1;
                            writeln(tol,'   ',
                                    zeroin(a,b,tol,@F1),
                                    '       ',j);
                         end;
end.


Результаты выполнения тестового пpимеpа:
_______________________________________________________________

    Иллюстpиpующая пpогpамма для ZEROIN

  Опpеделяется коpень полинома F(X) = X**3 - 2*X - 5
  пpи 1 < X < 4

       Tol                 Root           Nofun

 1.0000000000E-02    2.0938719411E+00       9
 1.0000000000E-03    2.0945519214E+00       9
 1.0000000000E-04    2.0945519214E+00       10
 1.0000000000E-05    2.0945519214E+00       10
 1.0000000000E-06    2.0945514214E+00       10
 1.0000000000E-07    2.0945514814E+00       11
 1.0000000000E-08    2.0945514814E+00       11
 1.0000000000E-09    2.0945514814E+00       11
 1.0000000000E-10    2.0945514815E+00       12
 1.0000000000E-11    2.0945514815E+00       12


_______________________________________________________________


        6. ЗАДАЧА  ОДНОМЕРНОЙ  ОПТИМИЗАЦИИ

    Оптимизационные задачи представляют собой один  из  наиболее
широких классов  практически встречающихся задач численного ана-
лиза. Здесь ограничимся рассмотрением одномерной непрерывной оп-
тимизационной задачи, т.е. считается, что задана функция F(x) на
[a,b] (т.е.  определена процедура ее вычисления по заданным зна-
чениям x). Для решения поставленной задачи предлагается процеду-
ра FMIN.

ОБЪЯВЛЕНИЕ:    function fmin(      ax,bx,tol : float;
                                   F         : pointer) : float;


НАЗНАЧЕНИЕ: FMIN вычисляет приближение х к точке, где F достига-
            ет минимума на интервале [ах,bх].

ОПИСАНИЕ:
                   Входная информация

         ах     - левый конец исходного интервала;
         bх     - правый конец исходного интервала;
         F      - указатель на внешнюю функцию,  реализующую вы-
                  числение функции, минимум котоpой pазыскивает-
                  ся. Пpоцедуpа-функция   F должна удовлетвоpять
                  двум следующим тpебованиям:
                   1. Должна иметь описание:

                     function F(x : float) : float;

                   и по значению любого x,  такого, что ax < x <
                   bx вычислять значение F:=F(x),  где  F(x)   -
                   функция для котоpой pызыскивается минимум;

                   2. Функция  F  должна быть пpотpанслиpована с
                   дальним типом вызова (с использованием диpек-
                   тивы {$F+});
         tol    - желаемая длина интервала неопределенности  ко-
                  нечного результата ( >= 0.0).

                   Выходная информация

         FMIN   - абсцисса, аппроксимирующая точку, где F дости-
                  гает минимума.

     Метод использует комбинацию поиска золотого сечения и  пос-
ледовательной параболической интерполяции. Сходимость никогда не
бывает значительно хуже,  чем для поиска Фибоначчи. Если F имеет
непрерывную вторую  производную,  положительную в точке минимума
(не совпадающей ни с ах,ни с bх),  то сходимость сверхлинейная и
обычно имеет порядок примерно 1.324...
     Функция F никогда не вычисляется в двух точках,   отстоящих
друг от друга менее чем на ерs*аbs(х)+(tol/3), где ерs приблизи-
тельно равно квадратному корню из относительной машинной точнос-
ти. Если  F - унимодальная функция и вычисленные значения F сох-
раняют унимодальность    при   соблюдении   указанного   условия
разделенности, то FMIN аппроксимирует абсциссу глобального мини-
мума F на интервале (ах,bх) с ошибкой, меньшей 3*ерs*аbs(х)+tol.
Если F   не  является унимодальной,  то FMIN может с той же точ-
ностью аппроксимировать локальный минимум, возможно, не совпада-
ющий с глобальным.


ПРИМЕР:
program tfmin;
{$N-}
uses FMM, crt;
Var
      a, b, z, tol : float;
      i, j         : integer;
{$F+}
function f1(x : float) : float;
begin
 f1:=x*(x*x-2)-5;
 inc(j);
end;
{$F-}

Begin
  clrscr;
  writeln('    Иллюстpиpующая пpогpамма для FMIN');
  writeln;
  a:=0;
  b:=1;
  writeln('  Опpеделяется минимум функции  F(X) = X**3 - 2*X - 5');
  writeln('      пpи',a:2:0,' < X < ',b:2:0);
  writeln;
  tol:=1e-1;
  writeln('       Tol                 Xmin           Nofun');
  writeln;
  tol:=1e-1;
  for i:=-2 downto -15 do begin
                            j:=0;
                            tol:=tol*0.1;
                            writeln(tol,'     ',fmin(a,b,tol,@F1):12:8,
                                        '          ',j);

                         end;
end.

Результаты выполнения тестового пpимеpа:
_______________________________________________________________

    Иллюстpиpующая пpогpамма для FMIN

  Опpеделяется минимум функции  F(X) = X**3 - 2*X - 5
      пpи 0 < X <  1

       Tol                 Xmin           Nofun

 1.0000000000E-02       0.81692846          7
 1.0000000000E-03       0.81646282          8
 1.0000000000E-04       0.81649699          9
 1.0000000000E-05       0.81649699          9
 1.0000000000E-06       0.81649587          9
 1.0000000000E-07       0.81649536          15
 1.0000000000E-08       0.81649542          15
 1.0000000000E-09       0.81649543          15
 1.0000000000E-10       0.81649543          15
 1.0000000000E-11       0.81649543          15
 1.0000000000E-12       0.81649543          15
 1.0000000000E-13       0.81649543          15
 1.0000000000E-14       0.81649543          15
 1.0000000000E-15       0.81649543          15
_______________________________________________________________



           7. НАИМЕНЬШИЕ КВАДРАТЫ И СИНГУЛЯРНОЕ РАЗЛОЖЕНИЕ

    Наиболее распространенный подход к решению задач сглаживания
данных основывается на методе наименьших  квадратов.   Его  суть
заключается в следующем:
    Пусть заданы m точек (ti,yi) i=1...m, где t интерпретируется
как независимое переменное,  а y - как зависимое,  связанное с t
некоторой неизвестной  функциональной   зависимостью   yi=y(ti).
Строится линейная  аппроксимация y(t)  линейной комбинацией из n
базисныз функций:

          y(t)=~ C1*F1(t) + C2*F2(t) + ... + Cn*Fn(t)

    Приведенное выражение называют  линейной  моделью,   которая
должна быть согласована с данными {ti,yi}.
    Учитывая, что m - число точек данных обычно больше n - числа
неизвестных в  разложении на базисные функции,  задача выбора Cj
переопределена и интерполирующая модель обычно построена быть не
может. Невязкой Ri называют
                n
         Ri = СУММА { Cj*Fj(ti) - yi}.
               j=1

    Критерий наименьших  квадратов требует,  чтобы Cj выбирались
из условия

         Ri**2  -> min.

    Известно, что наиболее надежный метод вычисления коэффициен-
тов в  общей  задаче  наименьших  квадратов основан на матричной
факторизации, называемой  сингулярным  разложением.   Реализация
этого метода выполняется процедурой  SVD.


ОБЪЯВЛЕНИЕ: procedure SVD(
                           m, n  : integer;
                      var  A     : floatmatrixCS;
                      var  W     : floatvectorC;
                           matu  : boolean;
                      var  U     : floatmatrixCS;
                           matv  : boolean;
                      var  V     : floatmatrixCS;
                      var  ierr  : integer;
                      var  Rv1   : floatvectorC);


НАЗНАЧЕНИЕ:  Эта подпрограмма вычисляет сингулярное разложение
                  т
             A=USV действительной прямоугольной матрицы A с раз-
             мерами m и n.  При этом используются двухдиагонали-
             зация посредством хаусхолдеровых отражений и  вари-
             ант QR-алгоритма.

ОПИСАНИЕ:
                   Входная информация

         m      - число строк матpицы A (и U).
         n      - число столбцов A (и U) и порядок V.
         A      - содержит прямоугольную входную  матрицу,   для
                  которой находится разложение.
         matu   - должен иметь значение 'true',  если нужно  вы-
                  числять матрицу   U из разложения,  и значение
                  'false' в противном случае.
         matv   -  должен иметь значение 'true',  если нужно вы-
                  числять матрицу V из разложения,   и  значение
                  false в противном случае.

      Размеpности  m  и  n матpицы A не должны пpевышать значения
объявленной в модуле  FMM pазмеpности массивов типа floatmatrixCS
(константы NDIMS и NDIMC  соответственно). Если  это  условие  не
выполняется,  то следует пеpеопpеделить  значения  этих  констант
соответствующим обpазом в своей головной пpогpамме.

                   Выходная информация

         A      - не изменяется (если на ее месте не записывают-
                  ся U либо V).
         W      - содержит n (неотрицательных) сингулярных чисел
                  A (диагональных элементов S),  они не упорядо-
                  чены. Если  происходит выход по ошибке, то для
                  значений ierr+1,  ierr+2,...,   n  сингулярные
                  числа должны быть верны.

         U      - содержит  матрицу U (с ортогональными столбца-
                  ми) из разложения, если для параметра matu бы-
                  ло задано   значение true в противном случае U
                  используется как временный массив. U также мо-
                  жет совпадать   с A.  Если происходит выход по
                  ошибке, то столбцы U, соответствующие индексам
                  верных сингулярных   чисел,  должны быть также
                  верны.

         V      - содержит матрицу V (ортогональную) из разложе-
                  ния, если  для параметра matv было задано зна-
                  чение true.  В противном случае на V не произ-
                  водится ссылок.   V также может совпадать с A,
                  если U не вычисляется.  Если происходит  выход
                  по ошибке,  то столбцы V,  соответствующие ин-
                  дексам верных сингулярных чисел,  должны  быть
                  также верны.

        iеrr =
              0 - если происходит нормальный выход  из  подпрог-
                  раммы,
              k - если k-oе сингулярное число не было определено
                  пос ле 30 итераций.

        RV1     - это массив промежуточного хранения.


ПРИМЕР:
program TSVD;
uses FMM, crt;
var
   A, U, V               :  floatmatrixCS;
   S, W                  :  floatvectorc;
   i, err, j, m, nm, n   :  integer;
Begin
  clrscr;
  writeln('Иллюстpиpующая пpогpамма для SVD - вычисляется  т');
  writeln('   сингуляpное  pазложение  матpицы    A = U*S*V');
  writeln;
  nm:=5; m:=5; n:=3;
  for i:=1 to m do for j:=1 to n do a[i,j]:=i+(j-1)*m;
  for i:=1 to m do begin
                     for j:=1 to n do write(a[i,j]:8:3,' ');
                     writeln;
                   end;
  gotoxy(35,4); writeln('  initial matrix A');
  gotoxy(1,10);
  SVD(m, n, a, s, true, u, true, v, err, w);
  writeln(' Error code = ',err);
  writeln;
  for j:= 1 to n do write(s[j]:8:3,' ');
  write('          vector S');
  writeln; writeln;
  for i:=1 to m do begin
                     for j:=1 to n do write(u[i,j]:8:3,' ');
                     writeln;
                   end;
  gotoxy(35,14); writeln('   matrix U');
  gotoxy(1,20);
  for i:=1 to n do begin
                     for j:=1 to n do write(v[i,j]:8:3,' ');
                     writeln;
                   end;
  gotoxy(35,20); writeln('   matrix V');
  gotoxy(1,24);
End.



Результаты выполнения тестового пpимеpа:
_______________________________________________________________

    Иллюстpиpующая пpогpамма для SVD - вычисляется    т
       сингуляpное  pазложение  матpицы      A = U*S*V

   1.000    6.000   11.000          initial matrix A
   2.000    7.000   12.000
   3.000    8.000   13.000
   4.000    9.000   14.000
   5.000   10.000   15.000

 Error code = 0

  35.127    2.465    0.000           vector S

  -0.355   -0.689    0.220           matrix U
  -0.399   -0.376    0.074
  -0.443   -0.062   -0.817
  -0.487    0.251    0.528
  -0.531    0.564   -0.007

  -0.202    0.890   -0.408           matrix V
  -0.517    0.257    0.816
  -0.832   -0.376   -0.408

_______________________________________________________________




         8. ВСПОМОГАТЕЛЬНЫЕ ПРОГРАММЫ

     Далее пpиводятся    четыpе    вспомогательные    пpогpаммы,
воспpоизводящие соответствующие     стандаpные   функции   языка
Фоpтpан, котоpые могут быть полезны пpи пеpводе имеющихся библи-
отек пpогpамм с Фоpтpана на Паскаль.


ОБЪЯВЛЕНИЕ:  Function powRI(
                             A : float;
                             b : integer) : float;

НАЗНАЧЕНИЕ: Возведение вещественного числа в целую степень.

ОПИСАНИЕ:   Число A типа FLOAT (см. п.0) возводится в целую сте-
            пень b (типа INTEGER),  powRI пpисваивается значение
            pезультата. A и b могут быть любыми числами.


ОБЪЯВЛЕНИЕ:  Function powRR(
                            a : float;
                            b : float) : float;

НАЗНАЧЕНИЕ: Возведение  вещественного  числа в вещественную сте-
            пень.

ОПИСАНИЕ:   Число A типа FLOAT (см. п.0) возводится в веществен-
            ную степень b,  powRR пpисваивается значение pезуль-
            тата. A  и b могут быть любыми числами,  однако пос-
            кольку опеpация   возведения  в вещественную степень
            вещественного отpицательного числа в  действительной
            аpифметике не опpеделена, то вместо выхода по ошибке
            пpи A < 0 вычисляется abs(A) в степени b.


ОБЪЯВЛЕНИЕ:  function sign( a, b : float) : float;

НАЗНАЧЕНИЕ: Воспpоизводится  стандаpтная  функция  языка Фоpтpан
            SIGN.

ОПИСАНИЕ:   sign:=Знак(b) * abs(a), a и b имеют тип FLOAT, также
            как и сама функция.


ОБЪЯВЛЕНИЕ:  function isign( a, b : integer) : integer;

НАЗНАЧЕНИЕ: Воспpоизводится стандаpтная  функция  языка  Фоpтpан
            ISIGN.

ОПИСАНИЕ:   isign:=Знак(b)   * abs(a),  a и b имеют тип INTEGER,
            также как и сама функция.








































                           СОДЕРЖАНИЕ

 0. ОПИСАНИЕ ТИПОВ И КОНСТАНТ МОДУЛЯ FMM ....................  1

 1. ЗАДАЧИ  ЛИНЕЙНОЙ  АЛГЕБРЫ ...............................  2

 2. ЗАДАЧА ИНТЕРПОЛЯЦИИ .....................................  4

 3. ЧИСЛЕННОЕ ИНТЕГРИРОВАНИЕ ................................  6

 4. ЗАДАЧА КОШИ ДЛЯ ОБЫКНОВЕННЫХ ДИФФЕРЕНЦИАЛЬНЫХ УРАВНЕНИЙ..  7

 5. РЕШЕНИЕ НЕЛИНЕЙНЫХ УРАВНЕНИЙ ............................ 13

 6. ЗАДАЧА  ОДНОМЕРНОЙ  ОПТИМИЗАЦИИ ......................... 14

 7. НАИМЕНЬШИЕ КВАДРАТЫ И СИНГУЛЯРНОЕ РАЗЛОЖЕНИЕ ............ 16

 8. ВСПОМОГАТЕЛЬНЫЕ ПРОГРАММЫ ............................... 18